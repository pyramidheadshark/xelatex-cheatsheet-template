% >>> Контент для шпаргалки "Алгоритмические Паттерны (LeetCode Medium Focus)"
% Версия с улучшениями от пользователя

% --- Введение ---
\begin{myblock}{Зачем нужны паттерны?}
    Собеседования по алгоритмам часто проверяют не знание сотен задач, а умение распознавать \textbf{основные подходы (паттерны)} к их решению. Знание паттернов позволяет быстро выбрать правильную структуру данных и алгоритм, даже если ты видишь задачу впервые. Это как иметь набор универсальных инструментов для разных типов винтов. Фокусируемся на паттернах, часто встречающихся в задачах уровня Medium на LeetCode.
\end{myblock}

% --- Раздел 1: Паттерны для Массивов/Строк ---
\section{Паттерны для Массивов/Строк}

\begin{textbox}{Паттерн: Два Указателя (Two Pointers)}
    \textbf{Идея:} Использование двух указателей (обычно индексов), которые движутся по массиву (или строке, или связанному списку) для выполнения какой-либо операции. Они могут двигаться навстречу друг другу, в одном направлении с разной скоростью или один может "ждать" другого. \sep
    \textbf{Аналогия:} Два человека идут по тропинке. Либо навстречу (например, найти место встречи посередине), либо один догоняет другого (проверить, есть ли цикл), либо идут вместе с фиксированным расстоянием (скользящее окно, но без изменения размера). \sep
    \textbf{Типовые задачи:}
    \begin{itemize}[nosep, leftmargin=*]
        % *** ИЗМЕНЕНИЕ 1: Добавлен акцент на сортировку ***
        \item Найти два числа в \textit{\textbf{отсортированном}} массиве, сумма которых равна X. (Указатели с разных концов).
        \item Проверить, является ли строка палиндромом. (Указатели с разных концов).
        \item Удалить дубликаты из \textit{отсортированного} массива "на месте". (Один указатель пишет, другой читает).
        \item Найти цикл в связанном списке (см. раздел "Связанные списки").
    \end{itemize} \sep
    \textbf{Сложность:} Обычно \textbf{$O(N)$} по времени, \textbf{$O(1)$} по памяти (если модификация "на месте").
\end{textbox}

\begin{textbox}{Паттерн: Скользящее Окно (Sliding Window)}
    \textbf{Идея:} Поддержание "окна" (подмассива или подстроки) определенного размера (или с определенными свойствами), которое "скользит" по основной структуре данных. Часто используется для задач, связанных с поиском оптимального непрерывного подмассива/подстроки. Размер окна может быть фиксированным или динамическим. \sep
    \textbf{Аналогия:} Лупа, которую двигают вдоль длинного текста, чтобы рассмотреть фрагмент (окно). Размер лупы (окна) может быть постоянным или меняться. \sep
    \textbf{Типовые задачи:}
    \begin{itemize}[nosep, leftmargin=*]
        \item Найти максимальную/минимальную сумму подмассива \textit{фиксированного} размера K.
        \item Найти длину самой длинной подстроки \textit{без повторяющихся символов}. (Размер окна динамический).
        \item Найти все анаграммы подстроки S1 в строке S2. (Окно размера S1, проверяем совпадение частот символов).
    \end{itemize} \sep
    \textbf{Сложность:} Обычно \textbf{$O(N)$} по времени (каждый элемент посещается 1-2 раза), \textbf{$O(k)$} или \textbf{$O(1)$} по памяти (k - размер алфавита или окна, если храним его содержимое). \sep % *** Добавлен \sep для отступа ***
    % *** ИЗМЕНЕНИЕ 2: Добавлено замечание про хеш-таблицы ***
    \textit{(Часто внутри окна используется \texttt{dict} или \texttt{set} для отслеживания состояния, например, частот символов.)}
    \begin{codebox}{python}{Общая структура (динамическое окно)}
    left = 0
    result = ...
    current_window_state = ... # e.g., dict, set

    for right in range(len(data)):
        # Расширяем окно вправо
        add_element(data[right], current_window_state)

        # Сжимаем окно слева, пока условие не выполнится
        while not is_window_valid(current_window_state):
            remove_element(data[left], current_window_state)
            left += 1

        # Обновляем результат, если нужно
        update_result(result, current_window_state)

    return result
    \end{codebox}
\end{textbox}

\begin{textbox}{Паттерн: Хеш-таблица / Словарь (Hash Table / Dictionary)}
    % *** ИЗМЕНЕНИЕ 3а: Усилено про скорость ***
    \textbf{Идея:} Использование структуры данных "ключ-значение" для \textbf{сверхбыстрого} ($\approx$ $O(1)$ в среднем) поиска, добавления или проверки наличия элемента. Незаменимо, когда нужно часто проверять наличие элемента или считать частоты. В Python это `dict` и `set`. \sep
    \textbf{Аналогия:} Гардероб с номерками. По номерку (ключу) ты мгновенно находишь свою куртку (значение). Или телефонная книга: по имени (ключу) находишь номер (значение). \sep
    \textbf{Типовые задачи:}
    \begin{itemize}[nosep, leftmargin=*]
        \item \textbf{Two Sum:} Найти два числа в массиве (не обязательно отсортированном), сумма которых равна X. (Храним `value -> index` в `dict`).
        \item Группировка анаграмм. (Ключ - отсортированная строка или кортеж частот в `dict`, значение - список строк).
        \item Найти первый неповторяющийся символ в строке. (Храним `char -> count` в `dict`).
        % *** ИЗМЕНЕНИЕ 3б: Уточнено про set vs dict ***
        \item Проверить, содержит ли массив дубликаты. (Используем `set` для проверки наличия; `dict` – для хранения счетчиков или индексов).
    \end{itemize} \sep
    \textbf{Сложность:} В среднем \textbf{$O(1)$} для `get`, `insert`, `delete`. \textbf{$O(N)$} по времени для обхода всей таблицы. \textbf{$O(N)$} по памяти в худшем случае для хранения N элементов. Помните про возможные коллизии и $O(N)$ в худшем случае для операций, но на практике редко.
\end{textbox}

% --- Раздел 2: Базовые Алгоритмы и Структуры ---
\section{Базовые Алгоритмы и Структуры}

\begin{myblock}{Сортировки (Важна Идея и Сложность)}
    \textbf{Идея:} Упорядочивание элементов коллекции. Редко нужно реализовывать сортировку с нуля на собеседовании (если только не попросят), но важно знать \textit{принцип работы} и \textit{сложность} эффективных алгоритмов (`Merge Sort`, `Quick Sort`). \sep
    \textbf{Аналогия:}
    \begin{itemize}[nosep, leftmargin=*]
        \item \textbf{Merge Sort (Слиянием):} Разделяй и властвуй. Как сортировать большую колоду карт: раздели пополам, отсортируй каждую половину (рекурсивно), затем аккуратно слей две отсортированные стопки в одну.
        \item \textbf{Quick Sort (Быстрая):} Выбери "опорную" карту. Все карты меньше нее положи налево, все больше - направо. Повтори для левой и правой кучек.
    \end{itemize} \sep
    \textbf{Когда использовать?} Часто как \textbf{предварительный шаг} для других алгоритмов (например, для "Двух указателей"). \sep
    \textbf{Сложность:}
    \begin{itemize}[nosep, leftmargin=*]
        \item Merge Sort: \textbf{$O(N \log N)$} время (всегда), \textbf{$O(N)$} память (для слияния).
        \item Quick Sort: \textbf{$O(N \log N)$} время (в среднем), \textbf{$O(N^2)$} (в худшем случае, редкий для хороших реализаций), \textbf{$O(\log N)$} память (в среднем, для стека рекурсии).
    \end{itemize}
    \begin{codebox}{text}{Итог по сложности}
    Алгоритм       | Время (среднее) | Время (худшее) | Память (доп.)
    ---------------|-----------------|----------------|--------------
    Merge Sort     | $O(N \log N)$   | $O(N \log N)$  | $O(N)$
    Quick Sort     | $O(N \log N)$   | $O(N^2)$       | $O(\log N)$
    Встроенная sort| $O(N \log N)$*  | $O(N \log N)$* | $O(N)$ или $O(\log N)$**
    * Обычно гибридные (TimSort в Python, IntroSort в C++).
    ** Зависит от реализации (TimSort - O(N), IntroSort - O(log N)).
    \end{codebox} \sep % *** Добавлен \sep для отступа ***
    % *** ИЗМЕНЕНИЕ 4: Добавлено про встроенные сортировки ***
    \textit{(Встроенные сортировки (\texttt{sort()}, \texttt{sorted()}) в Python (TimSort) и других языках часто являются гибридными и высокооптимизированными, поэтому их почти всегда предпочтительнее использовать на практике.)}
\end{myblock}

\begin{myblock}{Связанные Списки (Linked Lists)}
    \textbf{Идея:} Линейная структура, где каждый элемент (узел) содержит данные и \textit{указатель} на следующий элемент. Нет индексов, доступ только последовательный. \sep
    \textbf{Аналогия:} Квест "найди сокровище". Каждая записка (узел) говорит, где искать следующую. \sep
    \textbf{Типовые задачи:}
    \begin{itemize}[nosep, leftmargin=*]
        \item \textbf{Реверс списка:} Изменить указатели так, чтобы список шел в обратном порядке. (Классика: три указателя `prev`, `current`, `next`).
        \item \textbf{Обнаружение цикла:} Определить, есть ли в списке узел, указывающий на один из предыдущих узлов. (Паттерн "Два указателя": быстрый и медленный, "Черепаха и Заяц").
        \item Найти средний элемент. (Два указателя: один идет на 1 шаг, другой на 2).
        \item Слияние двух отсортированных списков.
    \end{itemize} \sep
    \textbf{Сложность:} Зависит от задачи. Реверс - \textbf{$O(N)$} время, \textbf{$O(1)$} память. Обнаружение цикла - \textbf{$O(N)$} время, \textbf{$O(1)$} память. Доступ к k-му элементу - \textbf{$O(k)$} время. Вставка/удаление в начале - \textbf{$O(1)$}. \sep % *** Добавлен \sep для отступа ***
    % *** ИЗМЕНЕНИЕ 5: Добавлен трейд-офф с массивами ***
    \textit{(Ключевой трейд-офф с массивами: быстрая $O(1)$ вставка/удаление \textbf{по известному узлу} (в начале/конце или если есть указатель), но медленный $O(N)$ доступ к элементу по индексу.)}
    \begin{codebox}{python}{Обнаружение цикла (Черепаха и Заяц)}
    slow = head
    fast = head
    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True # Цикл найден
    return False # Цикла нет
    \end{codebox}
\end{myblock}

% --- Раздел 3: Деревья и Рекурсия/ДП ---
\section{Деревья и Рекурсия/ДП}

\begin{textbox}{Деревья: Обходы BFS и DFS}
    \textbf{Идея:} Иерархическая структура данных. Обходы - способ посетить все узлы.
    \begin{itemize}[nosep, leftmargin=*]
        \item \textbf{BFS (Поиск в ширину / Breadth-First Search):} Исследование "уровень за уровнем". Использует \textbf{очередь (Queue)}.
        \item \textbf{DFS (Поиск в глубину / Depth-First Search):} Исследование "вглубь до упора, затем возврат". Использует \textbf{рекурсию} (неявный стек) или \textbf{явный стек (Stack)} для итеративной реализации. Варианты DFS: pre-order, in-order, post-order.
    \end{itemize} \sep
    \textbf{Аналогия:}
    \begin{itemize}[nosep, leftmargin=*]
        \item BFS: Бросить камень в воду - волны расходятся по уровням. Или: поиск кратчайшего пути в лабиринте без весов - исследуем все соседние клетки, потом соседей соседей и т.д.
        \item DFS: Исследование лабиринта - идем по одному пути до тупика, возвращаемся, пробуем другой.
    \end{itemize} \sep
    \textbf{Типовые задачи:}
    \begin{itemize}[nosep, leftmargin=*]
        \item Поуровневый обход дерева (Level Order Traversal) - Классический BFS.
        \item Найти максимальную глубину дерева - DFS (рекурсивно или итеративно).
        \item Проверить, является ли дерево бинарным деревом поиска (BST) - DFS (in-order обход).
        \item Найти путь от корня к узлу с заданной суммой - DFS.
    \end{itemize} \sep
    \textbf{Сложность:} \textbf{$O(N)$} по времени (N - число узлов, посещаем каждый). \textbf{$O(W)$} по памяти для BFS (W - макс. ширина дерева, в худшем случае $N/2$). \textbf{$O(H)$} по памяти для DFS (H - высота дерева, для стека рекурсии/итерации, в худшем случае N). \sep % *** Добавлен \sep для отступа ***
    % *** ИЗМЕНЕНИЕ 6: Добавлен раздел "Когда использовать?" ***
    \textbf{Когда использовать?}
    \begin{itemize}[nosep, leftmargin=*]
        \item \textbf{BFS:} Поиск кратчайшего пути в \textit{невзвешенном} графе/дереве, поуровневый обход, задачи "ближайший сосед".
        \item \textbf{DFS:} Проверка связности, поиск цикла, поиск пути (не обязательно кратчайшего), задачи, требующие исследования ветки до конца (например, проверка валидности BST), многие задачи на бэктрекинг. Часто проще реализовать рекурсивно.
    \end{itemize}
    \begin{codebox}{python}{Структура BFS (итеративно)}
    from collections import deque
    if not root: return []
    queue = deque([root])
    result = []
    while queue:
        level_size = len(queue)
        current_level = []
        for _ in range(level_size):
            node = queue.popleft()
            current_level.append(node.val)
            if node.left: queue.append(node.left)
            if node.right: queue.append(node.right)
        result.append(current_level) # или другая обработка
    return result
    \end{codebox}
    \begin{codebox}{python}{Структура DFS (рекурсивно, pre-order)}
    result = []
    def dfs(node):
        if not node: return
        result.append(node.val) # Pre-order: Visit node first
        dfs(node.left)
        dfs(node.right)
        # In-order: dfs(left), visit, dfs(right)
        # Post-order: dfs(left), dfs(right), visit
    dfs(root)
    return result
    \end{codebox}
\end{textbox}

% Используем упрощенный заголовок из предыдущего шага
\begin{alerttextbox}{Рекурсия / Бэктрекинг / ДП}
    Эти концепции тесно связаны и часто используются вместе, особенно в задачах на деревьях, графах и комбинаторике. \sep
    \textbf{Рекурсия:}
    \begin{itemize}[nosep, leftmargin=*]
        \item \textbf{Идея:} Функция вызывает саму себя для решения подзадачи меньшего размера. Обязательны \textit{базовый случай} (условие остановки) и \textit{рекурсивный шаг}.
        \item \textbf{Аналогия:} Матрешка. Чтобы открыть самую маленькую, нужно открыть все большие над ней.
        \item \textbf{Примеры:} Обходы деревьев (DFS), вычисление факториала.
    \end{itemize} \sep
    \textbf{Бэктрекинг (Backtracking):}
    \begin{itemize}[nosep, leftmargin=*]
        % *** ИЗМЕНЕНИЕ 7а: Уточнена связь рекурсии и бэктрекинга ***
        \item \textbf{Идея:} Систематический перебор всех возможных кандидатов в решении. Строим решение по шагам. Если текущий шаг ведет в тупик (не может привести к решению), "откатываемся" (backtrack) и пробуем другой вариант. Часто реализуется через \textbf{рекурсивный DFS}, где на каждом шаге пробуются варианты, и происходит 'откат' при неудаче.
        \item \textbf{Аналогия:} Поиск выхода из лабиринта: идешь по пути, если тупик - возвращаешься к развилке и пробуешь другой путь.
        \item \textbf{Примеры:} Генерация всех перестановок/комбинаций/подмножеств, решение Судоку, задача N ферзей.
    \end{itemize} \sep
    \textbf{Динамическое Программирование (ДП / DP):}
    \begin{itemize}[nosep, leftmargin=*]
        % *** ИЗМЕНЕНИЕ 7б: Уточнена связь рекурсии и ДП ***
        \item \textbf{Идея:} Решение задачи путем разбиения ее на \textit{перекрывающиеся подзадачи} и решения каждой подзадачи только один раз, сохраняя ее результат (мемоизация или табуляция) для будущего использования. Требует наличия \textit{оптимальной подструктуры}. Ключевое отличие от 'наивной' рекурсии — эффективная обработка \textbf{перекрывающихся подзадач} за счет сохранения их решений.
        \item \textbf{Аналогия:} Строительство из Lego. Чтобы построить большой замок (решить задачу), ты сначала строишь башни и стены (решаешь подзадачи). Если тебе снова нужна точно такая же башня, ты берешь уже готовую (сохраненный результат), а не строишь заново.
        \item \textbf{Примеры:} Числа Фибоначчи, задача о рюкзаке, поиск самой длинной общей подпоследовательности, "Лесенка" (Climbing Stairs).
        \item \textbf{Подходы:}
            \begin{itemize}
                \item \textit{Мемоизация (Top-Down):} Рекурсивное решение + кеширование результатов (обычно через словарь/массив).
                \item \textit{Табуляция (Bottom-Up):} Итеративное заполнение таблицы (массива) результатами подзадач, начиная с самых маленьких.
            \end{itemize}
    \end{itemize} \sep
    \textbf{Сложность:} Сильно зависит от задачи. Может быть от полиномиальной (ДП на Фибоначчи - $O(N)$) до экспоненциальной (бэктрекинг для перестановок - $O(N!)$).
    \begin{codebox}{python}{Пример ДП (Фибоначчи с мемоизацией)}
    memo = {}
    def fib(n):
        if n in memo: return memo[n]
        if n <= 1: return n
        result = fib(n-1) + fib(n-2)
        memo[n] = result
        return result
    \end{codebox}
\end{alerttextbox}

% --- Конец контента ---